"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoticeFilter = exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.formatNotices = exports.filterNotices = exports.generateMessage = exports.displayNotices = exports.refreshNotices = void 0;
const https = require("https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const logging_1 = require("./logging");
const util_1 = require("./util");
const directories_1 = require("./util/directories");
const version_1 = require("./version");
const CACHE_FILE_PATH = path.join(directories_1.cdkCacheDir(), 'notices.json');
async function refreshNotices() {
    const dataSource = dataSourceReference(false);
    return dataSource.fetch();
}
exports.refreshNotices = refreshNotices;
async function displayNotices(props) {
    var _a;
    const dataSource = dataSourceReference((_a = props.ignoreCache) !== null && _a !== void 0 ? _a : false);
    logging_1.print(await generateMessage(dataSource, props));
    return 0;
}
exports.displayNotices = displayNotices;
async function generateMessage(dataSource, props) {
    const data = await dataSource.fetch();
    const individualMessages = formatNotices(filterNotices(data, {
        outdir: props.outdir,
        acknowledgedIssueNumbers: new Set(props.acknowledgedIssueNumbers),
    }));
    if (individualMessages.length > 0) {
        return finalMessage(individualMessages, data[0].issueNumber);
    }
    return '';
}
exports.generateMessage = generateMessage;
function dataSourceReference(ignoreCache) {
    return new CachedDataSource(CACHE_FILE_PATH, new WebsiteNoticeDataSource(), ignoreCache);
}
function finalMessage(individualMessages, exampleNumber) {
    return [
        '\nNOTICES',
        ...individualMessages,
        `If you donâ€™t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${exampleNumber}".`,
    ].join('\n\n');
}
function filterNotices(data, options) {
    var _a, _b, _c;
    const filter = new NoticeFilter({
        cliVersion: (_a = options.cliVersion) !== null && _a !== void 0 ? _a : version_1.versionNumber(),
        acknowledgedIssueNumbers: (_b = options.acknowledgedIssueNumbers) !== null && _b !== void 0 ? _b : new Set(),
        tree: loadTree((_c = options.outdir) !== null && _c !== void 0 ? _c : 'cdk.out').tree,
    });
    return data.filter(notice => filter.apply(notice));
}
exports.filterNotices = filterNotices;
function formatNotices(data) {
    return data.map(formatNotice);
}
exports.formatNotices = formatNotices;
class WebsiteNoticeDataSource {
    fetch() {
        return new Promise((resolve) => {
            try {
                const req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                resolve(data !== null && data !== void 0 ? data : []);
                            }
                            catch (e) {
                                logging_1.debug(`Failed to parse notices: ${e}`);
                                resolve([]);
                            }
                        });
                        res.on('error', e => {
                            logging_1.debug(`Failed to fetch notices: ${e}`);
                            resolve([]);
                        });
                    }
                    else {
                        logging_1.debug(`Failed to fetch notices. Status code: ${res.statusCode}`);
                        resolve([]);
                    }
                });
                req.on('error', e => {
                    logging_1.debug(`Error on request: ${e}`);
                    resolve([]);
                });
            }
            catch (e) {
                logging_1.debug(`HTTPS 'get' call threw an error: ${e}`);
                resolve([]);
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE = 60 * 60 * 1000; // 1 hour
class CachedDataSource {
    constructor(fileName, dataSource, skipCache) {
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        var _a;
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = (_a = cachedData.expiration) !== null && _a !== void 0 ? _a : 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = {
                expiration: Date.now() + TIME_TO_LIVE,
                notices: await this.dataSource.fetch(),
            };
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            return data;
        }
    }
    async load() {
        try {
            return await fs.readJSON(this.fileName);
        }
        catch (e) {
            logging_1.debug(`Failed to load notices from cache: ${e}`);
            return {
                expiration: 0,
                notices: [],
            };
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            logging_1.debug(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
class NoticeFilter {
    constructor(props) {
        this.props = props;
        this.acknowledgedIssueNumbers = props.acknowledgedIssueNumbers;
    }
    /**
     * Returns true iff we should show this notice.
     */
    apply(notice) {
        if (this.acknowledgedIssueNumbers.has(notice.issueNumber)) {
            return false;
        }
        return this.applyVersion(notice, 'cli', this.props.cliVersion) ||
            match(resolveAliases(notice.components), this.props.tree);
    }
    /**
     * Returns true iff we should show the notice.
     */
    applyVersion(notice, name, compareToVersion) {
        if (compareToVersion === undefined) {
            return false;
        }
        const affectedComponent = notice.components.find(component => component.name === name);
        const affectedRange = affectedComponent === null || affectedComponent === void 0 ? void 0 : affectedComponent.version;
        return affectedRange != null && semver.satisfies(compareToVersion, affectedRange);
    }
}
exports.NoticeFilter = NoticeFilter;
/**
 * Some component names are aliases to actual component names. For example "framework"
 * is an alias for either the core library (v1) or the whole CDK library (v2).
 *
 * This function converts all aliases to their actual counterpart names, to be used to
 * match against the construct tree.
 *
 * @param components a list of components. Components whose name is an alias will be
 * transformed and all others will be left intact.
 */
function resolveAliases(components) {
    return util_1.flatMap(components, component => {
        if (component.name === 'framework') {
            return [{
                    name: '@aws-cdk/core.',
                    version: component.version,
                }, {
                    name: 'aws-cdk-lib.',
                    version: component.version,
                }];
        }
        else {
            return [component];
        }
    });
}
function formatNotice(notice) {
    const componentsValue = notice.components.map(c => `${c.name}: ${c.version}`).join(', ');
    return [
        `${notice.issueNumber}\t${notice.title}`,
        formatOverview(notice.overview),
        `\tAffected versions: ${componentsValue}`,
        `\tMore information at: https://github.com/aws/aws-cdk/issues/${notice.issueNumber}`,
    ].join('\n\n') + '\n';
}
function formatOverview(text) {
    const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
    const heading = 'Overview: ';
    const separator = `\n\t${' '.repeat(heading.length)}`;
    const content = wrap(text)
        .split('\n')
        .join(separator);
    return '\t' + heading + content;
}
/**
 * Whether any component in the tree matches any component in the query.
 * A match happens when:
 *
 * 1. The version of the node matches the version in the query, interpreted
 * as a semver range.
 *
 * 2. The name in the query is a prefix of the node name when the query ends in '.',
 * or the two names are exactly the same, otherwise.
 */
function match(query, tree) {
    return some(tree, node => {
        return query.some(component => {
            var _a, _b;
            return compareNames(component.name, (_a = node.constructInfo) === null || _a === void 0 ? void 0 : _a.fqn) &&
                compareVersions(component.version, (_b = node.constructInfo) === null || _b === void 0 ? void 0 : _b.version);
        });
    });
    function compareNames(pattern, target) {
        if (target == null) {
            return false;
        }
        return pattern.endsWith('.') ? target.startsWith(pattern) : pattern === target;
    }
    function compareVersions(pattern, target) {
        return semver.satisfies(target !== null && target !== void 0 ? target : '', pattern);
    }
}
function loadTree(outdir) {
    try {
        return fs.readJSONSync(path.join(outdir, 'tree.json'));
    }
    catch (e) {
        logging_1.debug(`Failed to get tree.json file: ${e}`);
        return {};
    }
}
function some(node, predicate) {
    return node != null && (predicate(node) || findInChildren());
    function findInChildren() {
        if (node.children == null) {
            return false;
        }
        for (const name in node.children) {
            if (some(node.children[name], predicate)) {
                return true;
            }
        }
        return false;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLHVDQUF5QztBQUN6QyxpQ0FBaUM7QUFDakMsb0RBQWlEO0FBQ2pELHVDQUEwQztBQUUxQyxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUFXLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztBQXVCMUQsS0FBSyxVQUFVLGNBQWM7SUFDbEMsTUFBTSxVQUFVLEdBQUcsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUMsT0FBTyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDNUIsQ0FBQztBQUhELHdDQUdDO0FBRU0sS0FBSyxVQUFVLGNBQWMsQ0FBQyxLQUEwQjs7SUFDN0QsTUFBTSxVQUFVLEdBQUcsbUJBQW1CLE9BQUMsS0FBSyxDQUFDLFdBQVcsbUNBQUksS0FBSyxDQUFDLENBQUM7SUFDbkUsZUFBSyxDQUFDLE1BQU0sZUFBZSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2hELE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQUpELHdDQUlDO0FBRU0sS0FBSyxVQUFVLGVBQWUsQ0FBQyxVQUE0QixFQUFFLEtBQTBCO0lBQzVGLE1BQU0sSUFBSSxHQUFHLE1BQU0sVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3RDLE1BQU0sa0JBQWtCLEdBQUcsYUFBYSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUU7UUFDM0QsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO1FBQ3BCLHdCQUF3QixFQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQztLQUNsRSxDQUFDLENBQUMsQ0FBQztJQUVKLElBQUksa0JBQWtCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFB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Q0FBQztTQUFFO1FBRTVDLEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNoQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLFNBQVMsQ0FBQyxFQUFFO2dCQUN4QyxPQUFPLElBQUksQ0FBQzthQUNiO1NBQ0Y7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgZGVidWcsIHByaW50IH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY2RrQ2FjaGVEaXIgfSBmcm9tICcuL3V0aWwvZGlyZWN0b3JpZXMnO1xuaW1wb3J0IHsgdmVyc2lvbk51bWJlciB9IGZyb20gJy4vdmVyc2lvbic7XG5cbmNvbnN0IENBQ0hFX0ZJTEVfUEFUSCA9IHBhdGguam9pbihjZGtDYWNoZURpcigpLCAnbm90aWNlcy5qc29uJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlzcGxheU5vdGljZXNQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgY2xvdWQgYXNzZW1ibHkgZGlyZWN0b3J5LiBVc3VhbGx5ICdjZGsub3V0Jy5cbiAgICovXG4gIHJlYWRvbmx5IG91dGRpcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJc3N1ZSBudW1iZXJzIG9mIG5vdGljZXMgdGhhdCBoYXZlIGJlZW4gYWNrbm93bGVkZ2VkIGJ5IGEgdXNlclxuICAgKiBvZiB0aGUgY3VycmVudCBDREsgcmVwb3NpdG9yeS4gVGhlc2Ugbm90aWNlcyB3aWxsIGJlIHNraXBwZWQuXG4gICAqL1xuICByZWFkb25seSBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IG51bWJlcltdO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGNhY2hlZCBub3RpY2VzIHNob3VsZCBiZSBpZ25vcmVkLiBTZXR0aW5nIHRoaXMgcHJvcGVydHlcbiAgICogdG8gdHJ1ZSB3aWxsIGZvcmNlIHRoZSBDTEkgdG8gZG93bmxvYWQgZnJlc2ggZGF0YVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaWdub3JlQ2FjaGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaE5vdGljZXMoKSB7XG4gIGNvbnN0IGRhdGFTb3VyY2UgPSBkYXRhU291cmNlUmVmZXJlbmNlKGZhbHNlKTtcbiAgcmV0dXJuIGRhdGFTb3VyY2UuZmV0Y2goKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpc3BsYXlOb3RpY2VzKHByb3BzOiBEaXNwbGF5Tm90aWNlc1Byb3BzKSB7XG4gIGNvbnN0IGRhdGFTb3VyY2UgPSBkYXRhU291cmNlUmVmZXJlbmNlKHByb3BzLmlnbm9yZUNhY2hlID8/IGZhbHNlKTtcbiAgcHJpbnQoYXdhaXQgZ2VuZXJhdGVNZXNzYWdlKGRhdGFTb3VyY2UsIHByb3BzKSk7XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVNZXNzYWdlKGRhdGFTb3VyY2U6IE5vdGljZURhdGFTb3VyY2UsIHByb3BzOiBEaXNwbGF5Tm90aWNlc1Byb3BzKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBkYXRhU291cmNlLmZldGNoKCk7XG4gIGNvbnN0IGluZGl2aWR1YWxNZXNzYWdlcyA9IGZvcm1hdE5vdGljZXMoZmlsdGVyTm90aWNlcyhkYXRhLCB7XG4gICAgb3V0ZGlyOiBwcm9wcy5vdXRkaXIsXG4gICAgYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzOiBuZXcgU2V0KHByb3BzLmFja25vd2xlZGdlZElzc3VlTnVtYmVycyksXG4gIH0pKTtcblxuICBpZiAoaW5kaXZpZHVhbE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZmluYWxNZXNzYWdlKGluZGl2aWR1YWxNZXNzYWdlcywgZGF0YVswXS5pc3N1ZU51bWJlcik7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBkYXRhU291cmNlUmVmZXJlbmNlKGlnbm9yZUNhY2hlOiBib29sZWFuKTogTm90aWNlRGF0YVNvdXJjZSB7XG4gIHJldHVybiBuZXcgQ2FjaGVkRGF0YVNvdXJjZShDQUNIRV9GSUxFX1BBVEgsIG5ldyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSgpLCBpZ25vcmVDYWNoZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmFsTWVzc2FnZShpbmRpdmlkdWFsTWVzc2FnZXM6IHN0cmluZ1tdLCBleGFtcGxlTnVtYmVyOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gW1xuICAgICdcXG5OT1RJQ0VTJyxcbiAgICAuLi5pbmRpdmlkdWFsTWVzc2FnZXMsXG4gICAgYElmIHlvdSBkb27igJl0IHdhbnQgdG8gc2VlIGEgbm90aWNlIGFueW1vcmUsIHVzZSBcImNkayBhY2tub3dsZWRnZSA8aWQ+XCIuIEZvciBleGFtcGxlLCBcImNkayBhY2tub3dsZWRnZSAke2V4YW1wbGVOdW1iZXJ9XCIuYCxcbiAgXS5qb2luKCdcXG5cXG4nKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJOb3RpY2VPcHRpb25zIHtcbiAgb3V0ZGlyPzogc3RyaW5nLFxuICBjbGlWZXJzaW9uPzogc3RyaW5nLFxuICBmcmFtZXdvcmtWZXJzaW9uPzogc3RyaW5nLFxuICBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM/OiBTZXQ8bnVtYmVyPixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlck5vdGljZXMoZGF0YTogTm90aWNlW10sIG9wdGlvbnM6IEZpbHRlck5vdGljZU9wdGlvbnMpOiBOb3RpY2VbXSB7XG4gIGNvbnN0IGZpbHRlciA9IG5ldyBOb3RpY2VGaWx0ZXIoe1xuICAgIGNsaVZlcnNpb246IG9wdGlvbnMuY2xpVmVyc2lvbiA/PyB2ZXJzaW9uTnVtYmVyKCksXG4gICAgYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzOiBvcHRpb25zLmFja25vd2xlZGdlZElzc3VlTnVtYmVycyA/PyBuZXcgU2V0KCksXG4gICAgdHJlZTogbG9hZFRyZWUob3B0aW9ucy5vdXRkaXIgPz8gJ2Nkay5vdXQnKS50cmVlLFxuICB9KTtcbiAgcmV0dXJuIGRhdGEuZmlsdGVyKG5vdGljZSA9PiBmaWx0ZXIuYXBwbHkobm90aWNlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROb3RpY2VzKGRhdGE6IE5vdGljZVtdKTogc3RyaW5nW10ge1xuICByZXR1cm4gZGF0YS5tYXAoZm9ybWF0Tm90aWNlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnQge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZlcnNpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2Uge1xuICB0aXRsZTogc3RyaW5nO1xuICBpc3N1ZU51bWJlcjogbnVtYmVyO1xuICBvdmVydmlldzogc3RyaW5nO1xuICBjb21wb25lbnRzOiBDb21wb25lbnRbXTtcbiAgc2NoZW1hVmVyc2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZURhdGFTb3VyY2Uge1xuICBmZXRjaCgpOiBQcm9taXNlPE5vdGljZVtdPixcbn1cblxuZXhwb3J0IGNsYXNzIFdlYnNpdGVOb3RpY2VEYXRhU291cmNlIGltcGxlbWVudHMgTm90aWNlRGF0YVNvdXJjZSB7XG4gIGZldGNoKCk6IFByb21pc2U8Tm90aWNlW10+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IGh0dHBzLmdldCgnaHR0cHM6Ly9jbGkuY2RrLmRldi10b29scy5hd3MuZGV2L25vdGljZXMuanNvbicsIHJlcyA9PiB7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlcy5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgICAgICAgbGV0IHJhd0RhdGEgPSAnJztcbiAgICAgICAgICAgIHJlcy5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICByYXdEYXRhICs9IGNodW5rO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyYXdEYXRhKS5ub3RpY2VzIGFzIE5vdGljZVtdO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSA/PyBbXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgRmFpbGVkIHRvIHBhcnNlIG5vdGljZXM6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMub24oJ2Vycm9yJywgZSA9PiB7XG4gICAgICAgICAgICAgIGRlYnVnKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlczogJHtlfWApO1xuICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhgRmFpbGVkIHRvIGZldGNoIG5vdGljZXMuIFN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXNDb2RlfWApO1xuICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICAgIGRlYnVnKGBFcnJvciBvbiByZXF1ZXN0OiAke2V9YCk7XG4gICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyhgSFRUUFMgJ2dldCcgY2FsbCB0aHJldyBhbiBlcnJvcjogJHtlfWApO1xuICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FjaGVkTm90aWNlcyB7XG4gIGV4cGlyYXRpb246IG51bWJlcixcbiAgbm90aWNlczogTm90aWNlW10sXG59XG5cbmNvbnN0IFRJTUVfVE9fTElWRSA9IDYwICogNjAgKiAxMDAwOyAvLyAxIGhvdXJcblxuZXhwb3J0IGNsYXNzIENhY2hlZERhdGFTb3VyY2UgaW1wbGVtZW50cyBOb3RpY2VEYXRhU291cmNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBmaWxlTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGF0YVNvdXJjZTogTm90aWNlRGF0YVNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNraXBDYWNoZT86IGJvb2xlYW4pIHtcbiAgfVxuXG4gIGFzeW5jIGZldGNoKCk6IFByb21pc2U8Tm90aWNlW10+IHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gYXdhaXQgdGhpcy5sb2FkKCk7XG4gICAgY29uc3QgZGF0YSA9IGNhY2hlZERhdGEubm90aWNlcztcbiAgICBjb25zdCBleHBpcmF0aW9uID0gY2FjaGVkRGF0YS5leHBpcmF0aW9uID8/IDA7XG5cbiAgICBpZiAoRGF0ZS5ub3coKSA+IGV4cGlyYXRpb24gfHwgdGhpcy5za2lwQ2FjaGUpIHtcbiAgICAgIGNvbnN0IGZyZXNoRGF0YSA9IHtcbiAgICAgICAgZXhwaXJhdGlvbjogRGF0ZS5ub3coKSArIFRJTUVfVE9fTElWRSxcbiAgICAgICAgbm90aWNlczogYXdhaXQgdGhpcy5kYXRhU291cmNlLmZldGNoKCksXG4gICAgICB9O1xuICAgICAgYXdhaXQgdGhpcy5zYXZlKGZyZXNoRGF0YSk7XG4gICAgICByZXR1cm4gZnJlc2hEYXRhLm5vdGljZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZCgpOiBQcm9taXNlPENhY2hlZE5vdGljZXM+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGZzLnJlYWRKU09OKHRoaXMuZmlsZU5hbWUpIGFzIENhY2hlZE5vdGljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byBsb2FkIG5vdGljZXMgZnJvbSBjYWNoZTogJHtlfWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwaXJhdGlvbjogMCxcbiAgICAgICAgbm90aWNlczogW10sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZShjYWNoZWQ6IENhY2hlZE5vdGljZXMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMud3JpdGVKU09OKHRoaXMuZmlsZU5hbWUsIGNhY2hlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byBzdG9yZSBub3RpY2VzIGluIHRoZSBjYWNoZTogJHtlfWApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZUZpbHRlclByb3BzIHtcbiAgY2xpVmVyc2lvbjogc3RyaW5nLFxuICBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IFNldDxudW1iZXI+LFxuICB0cmVlOiBDb25zdHJ1Y3RUcmVlTm9kZSxcbn1cblxuZXhwb3J0IGNsYXNzIE5vdGljZUZpbHRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzOiBTZXQ8bnVtYmVyPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBOb3RpY2VGaWx0ZXJQcm9wcykge1xuICAgIHRoaXMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzID0gcHJvcHMuYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZmYgd2Ugc2hvdWxkIHNob3cgdGhpcyBub3RpY2UuXG4gICAqL1xuICBhcHBseShub3RpY2U6IE5vdGljZSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmFja25vd2xlZGdlZElzc3VlTnVtYmVycy5oYXMobm90aWNlLmlzc3VlTnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5VmVyc2lvbihub3RpY2UsICdjbGknLCB0aGlzLnByb3BzLmNsaVZlcnNpb24pIHx8XG4gICAgICBtYXRjaChyZXNvbHZlQWxpYXNlcyhub3RpY2UuY29tcG9uZW50cyksIHRoaXMucHJvcHMudHJlZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmZiB3ZSBzaG91bGQgc2hvdyB0aGUgbm90aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseVZlcnNpb24obm90aWNlOiBOb3RpY2UsIG5hbWU6IHN0cmluZywgY29tcGFyZVRvVmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGNvbXBhcmVUb1ZlcnNpb24gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGNvbnN0IGFmZmVjdGVkQ29tcG9uZW50ID0gbm90aWNlLmNvbXBvbmVudHMuZmluZChjb21wb25lbnQgPT4gY29tcG9uZW50Lm5hbWUgPT09IG5hbWUpO1xuICAgIGNvbnN0IGFmZmVjdGVkUmFuZ2UgPSBhZmZlY3RlZENvbXBvbmVudD8udmVyc2lvbjtcbiAgICByZXR1cm4gYWZmZWN0ZWRSYW5nZSAhPSBudWxsICYmIHNlbXZlci5zYXRpc2ZpZXMoY29tcGFyZVRvVmVyc2lvbiwgYWZmZWN0ZWRSYW5nZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGNvbXBvbmVudCBuYW1lcyBhcmUgYWxpYXNlcyB0byBhY3R1YWwgY29tcG9uZW50IG5hbWVzLiBGb3IgZXhhbXBsZSBcImZyYW1ld29ya1wiXG4gKiBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIHRoZSBjb3JlIGxpYnJhcnkgKHYxKSBvciB0aGUgd2hvbGUgQ0RLIGxpYnJhcnkgKHYyKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGFsbCBhbGlhc2VzIHRvIHRoZWlyIGFjdHVhbCBjb3VudGVycGFydCBuYW1lcywgdG8gYmUgdXNlZCB0b1xuICogbWF0Y2ggYWdhaW5zdCB0aGUgY29uc3RydWN0IHRyZWUuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudHMgYSBsaXN0IG9mIGNvbXBvbmVudHMuIENvbXBvbmVudHMgd2hvc2UgbmFtZSBpcyBhbiBhbGlhcyB3aWxsIGJlXG4gKiB0cmFuc2Zvcm1lZCBhbmQgYWxsIG90aGVycyB3aWxsIGJlIGxlZnQgaW50YWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlQWxpYXNlcyhjb21wb25lbnRzOiBDb21wb25lbnRbXSk6IENvbXBvbmVudFtdIHtcbiAgcmV0dXJuIGZsYXRNYXAoY29tcG9uZW50cywgY29tcG9uZW50ID0+IHtcbiAgICBpZiAoY29tcG9uZW50Lm5hbWUgPT09ICdmcmFtZXdvcmsnKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgbmFtZTogJ0Bhd3MtY2RrL2NvcmUuJyxcbiAgICAgICAgdmVyc2lvbjogY29tcG9uZW50LnZlcnNpb24sXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdhd3MtY2RrLWxpYi4nLFxuICAgICAgICB2ZXJzaW9uOiBjb21wb25lbnQudmVyc2lvbixcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2NvbXBvbmVudF07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Tm90aWNlKG5vdGljZTogTm90aWNlKTogc3RyaW5nIHtcbiAgY29uc3QgY29tcG9uZW50c1ZhbHVlID0gbm90aWNlLmNvbXBvbmVudHMubWFwKGMgPT4gYCR7Yy5uYW1lfTogJHtjLnZlcnNpb259YCkuam9pbignLCAnKTtcbiAgcmV0dXJuIFtcbiAgICBgJHtub3RpY2UuaXNzdWVOdW1iZXJ9XFx0JHtub3RpY2UudGl0bGV9YCxcbiAgICBmb3JtYXRPdmVydmlldyhub3RpY2Uub3ZlcnZpZXcpLFxuICAgIGBcXHRBZmZlY3RlZCB2ZXJzaW9uczogJHtjb21wb25lbnRzVmFsdWV9YCxcbiAgICBgXFx0TW9yZSBpbmZvcm1hdGlvbiBhdDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy8ke25vdGljZS5pc3N1ZU51bWJlcn1gLFxuICBdLmpvaW4oJ1xcblxcbicpICsgJ1xcbic7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE92ZXJ2aWV3KHRleHQ6IHN0cmluZykge1xuICBjb25zdCB3cmFwID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC8oPyFbXlxcbl17MSw2MH0kKShbXlxcbl17MSw2MH0pXFxzL2csICckMVxcbicpO1xuXG4gIGNvbnN0IGhlYWRpbmcgPSAnT3ZlcnZpZXc6ICc7XG4gIGNvbnN0IHNlcGFyYXRvciA9IGBcXG5cXHQkeycgJy5yZXBlYXQoaGVhZGluZy5sZW5ndGgpfWA7XG4gIGNvbnN0IGNvbnRlbnQgPSB3cmFwKHRleHQpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5qb2luKHNlcGFyYXRvcik7XG5cbiAgcmV0dXJuICdcXHQnICsgaGVhZGluZyArIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogV2hldGhlciBhbnkgY29tcG9uZW50IGluIHRoZSB0cmVlIG1hdGNoZXMgYW55IGNvbXBvbmVudCBpbiB0aGUgcXVlcnkuXG4gKiBBIG1hdGNoIGhhcHBlbnMgd2hlbjpcbiAqXG4gKiAxLiBUaGUgdmVyc2lvbiBvZiB0aGUgbm9kZSBtYXRjaGVzIHRoZSB2ZXJzaW9uIGluIHRoZSBxdWVyeSwgaW50ZXJwcmV0ZWRcbiAqIGFzIGEgc2VtdmVyIHJhbmdlLlxuICpcbiAqIDIuIFRoZSBuYW1lIGluIHRoZSBxdWVyeSBpcyBhIHByZWZpeCBvZiB0aGUgbm9kZSBuYW1lIHdoZW4gdGhlIHF1ZXJ5IGVuZHMgaW4gJy4nLFxuICogb3IgdGhlIHR3byBuYW1lcyBhcmUgZXhhY3RseSB0aGUgc2FtZSwgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBtYXRjaChxdWVyeTogQ29tcG9uZW50W10sIHRyZWU6IENvbnN0cnVjdFRyZWVOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzb21lKHRyZWUsIG5vZGUgPT4ge1xuICAgIHJldHVybiBxdWVyeS5zb21lKGNvbXBvbmVudCA9PlxuICAgICAgY29tcGFyZU5hbWVzKGNvbXBvbmVudC5uYW1lLCBub2RlLmNvbnN0cnVjdEluZm8/LmZxbikgJiZcbiAgICAgIGNvbXBhcmVWZXJzaW9ucyhjb21wb25lbnQudmVyc2lvbiwgbm9kZS5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uKSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOYW1lcyhwYXR0ZXJuOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiBwYXR0ZXJuLmVuZHNXaXRoKCcuJykgPyB0YXJnZXQuc3RhcnRzV2l0aChwYXR0ZXJuKSA6IHBhdHRlcm4gPT09IHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyhwYXR0ZXJuOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModGFyZ2V0ID8/ICcnLCBwYXR0ZXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2FkVHJlZShvdXRkaXI6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBmcy5yZWFkSlNPTlN5bmMocGF0aC5qb2luKG91dGRpciwgJ3RyZWUuanNvbicpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKGBGYWlsZWQgdG8gZ2V0IHRyZWUuanNvbiBmaWxlOiAke2V9YCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKlxuICogU291cmNlIGluZm9ybWF0aW9uIG9uIGEgY29uc3RydWN0IChjbGFzcyBmcW4gYW5kIHZlcnNpb24pXG4gKi9cbmludGVyZmFjZSBDb25zdHJ1Y3RJbmZvIHtcbiAgcmVhZG9ubHkgZnFuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIG5vZGUgaW4gdGhlIGNvbnN0cnVjdCB0cmVlLlxuICogQGludGVybmFsXG4gKi9cbmludGVyZmFjZSBDb25zdHJ1Y3RUcmVlTm9kZSB7XG4gIHJlYWRvbmx5IGlkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHBhdGg6IHN0cmluZztcbiAgcmVhZG9ubHkgY2hpbGRyZW4/OiB7IFtrZXk6IHN0cmluZ106IENvbnN0cnVjdFRyZWVOb2RlIH07XG4gIHJlYWRvbmx5IGF0dHJpYnV0ZXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuXG4gIC8qKlxuICAgKiBJbmZvcm1hdGlvbiBvbiB0aGUgY29uc3RydWN0IGNsYXNzIHRoYXQgbGVkIHRvIHRoaXMgbm9kZSwgaWYgYXZhaWxhYmxlXG4gICAqL1xuICByZWFkb25seSBjb25zdHJ1Y3RJbmZvPzogQ29uc3RydWN0SW5mbztcbn1cblxuZnVuY3Rpb24gc29tZShub2RlOiBDb25zdHJ1Y3RUcmVlTm9kZSwgcHJlZGljYXRlOiAobjogQ29uc3RydWN0VHJlZU5vZGUpID0+IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUgIT0gbnVsbCAmJiAocHJlZGljYXRlKG5vZGUpIHx8IGZpbmRJbkNoaWxkcmVuKCkpO1xuXG4gIGZ1bmN0aW9uIGZpbmRJbkNoaWxkcmVuKCk6IGJvb2xlYW4ge1xuICAgIGlmIChub2RlLmNoaWxkcmVuID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgICAgaWYgKHNvbWUobm9kZS5jaGlsZHJlbltuYW1lXSwgcHJlZGljYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=