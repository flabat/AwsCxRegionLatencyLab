"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = void 0;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const logging_1 = require("../logging");
const aws_auth_1 = require("./aws-auth");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
/**
 * Perform a hotswap deployment,
 * short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting)).sdk;
    // The current resources of the Stack.
    // We need them to figure out the physical name of a resource in case it wasn't specified by the user.
    // We fetch it lazily, to save a service call, in case all hotswapped resources have their physical names set.
    const listStackResources = new evaluate_cloudformation_template_1.LazyListStackResources(sdk, stackArtifact.stackName);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackArtifact,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        urlSuffix: (region) => sdk.getEndpointSuffix(region),
        listStackResources,
    });
    const currentTemplate = await cloudFormationStack.template();
    const stackChanges = cfn_diff.diffTemplate(currentTemplate, stackArtifact.template);
    const hotswappableChanges = await findAllHotswappableChanges(stackChanges, evaluateCfnTemplate);
    if (!hotswappableChanges) {
        // this means there were changes to the template that cannot be short-circuited
        return undefined;
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs };
}
exports.tryHotswapDeployment = tryHotswapDeployment;
async function findAllHotswappableChanges(stackChanges, evaluateCfnTemplate) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    let foundNonHotswappableChange = false;
    const promises = [];
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        const resourceHotswapEvaluation = isCandidateForHotswapping(change);
        if (resourceHotswapEvaluation === common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT) {
            foundNonHotswappableChange = true;
        }
        else if (resourceHotswapEvaluation === common_1.ChangeHotswapImpact.IRRELEVANT) {
            // empty 'if' just for flow-aware typing to kick in...
        }
        else {
            promises.push([
                lambda_functions_1.isHotswappableLambdaFunctionChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                stepfunctions_state_machines_1.isHotswappableStateMachineChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                ecs_services_1.isHotswappableEcsServiceChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                code_build_projects_1.isHotswappableCodeBuildProjectChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
                appsync_mapping_templates_1.isHotswappableAppSyncChange(logicalId, resourceHotswapEvaluation, evaluateCfnTemplate),
            ]);
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        const hotswapDetectionResults = await Promise.all(detectorResultPromises);
        changesDetectionResults.push(hotswapDetectionResults);
    }
    const hotswappableResources = new Array();
    for (const hotswapDetectionResults of changesDetectionResults) {
        const perChangeHotswappableResources = new Array();
        for (const result of hotswapDetectionResults) {
            if (typeof result !== 'string') {
                perChangeHotswappableResources.push(result);
            }
        }
        // if we found any hotswappable changes, return now
        if (perChangeHotswappableResources.length > 0) {
            hotswappableResources.push(...perChangeHotswappableResources);
            continue;
        }
        // no hotswappable changes found, so at least one IRRELEVANT means we can ignore this change;
        // otherwise, all answers are REQUIRES_FULL_DEPLOYMENT, so this means we can't hotswap this change,
        // and have to do a full deployment instead
        if (!hotswapDetectionResults.some(hdr => hdr === common_1.ChangeHotswapImpact.IRRELEVANT)) {
            foundNonHotswappableChange = true;
        }
    }
    return foundNonHotswappableChange ? undefined : hotswappableResources;
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, resChange => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, resChange => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * returns `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if a resource was deleted, or a change that we cannot short-circuit occured.
 * Returns `ChangeHotswapImpact.IRRELEVANT` if a change that does not impact shortcircuiting occured, such as a metadata change.
 */
function isCandidateForHotswapping(change) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.newValue || !change.oldValue) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // Ignore Metadata changes
    if (change.newValue.Type === 'AWS::CDK::Metadata') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    return {
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    logging_1.print(`\n${common_1.ICON} hotswapping resources:`);
    return Promise.all(hotswappableChanges.map(hotswapOperation => {
        return applyHotswappableChange(sdk, hotswapOperation);
    }));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    try {
        for (const name of hotswapOperation.resourceNames) {
            logging_1.print(`   ${common_1.ICON} %s`, chalk.bold(name));
        }
        return await hotswapOperation.apply(sdk);
    }
    finally {
        for (const name of hotswapOperation.resourceNames) {
            logging_1.print(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
        }
        sdk.removeCustomUserAgent(customUserAgent);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseURBQXlEO0FBRXpELCtCQUErQjtBQUMvQix3Q0FBbUM7QUFDbkMseUNBQXFEO0FBRXJELHlGQUE0RztBQUM1RyxtRkFBa0Y7QUFDbEYsdUVBQXFGO0FBQ3JGLDZDQUFpSTtBQUNqSSx5REFBd0U7QUFDeEUsaUVBQWdGO0FBQ2hGLDJFQUF5RjtBQUN6Rix5RkFBMEY7QUFHMUY7Ozs7OztHQU1HO0FBQ0ksS0FBSyxVQUFVLG9CQUFvQixDQUN4QyxXQUF3QixFQUFFLFdBQXNDLEVBQ2hFLG1CQUF3QyxFQUFFLGFBQWdEO0lBRTFGLDJGQUEyRjtJQUMzRixNQUFNLFdBQVcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDcEYsOEdBQThHO0lBQzlHLGtHQUFrRztJQUNsRyxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sV0FBVyxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUUsZUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ2pGLHNDQUFzQztJQUN0QyxzR0FBc0c7SUFDdEcsOEdBQThHO0lBQzlHLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSx5REFBc0IsQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxpRUFBOEIsQ0FBQztRQUM3RCxhQUFhO1FBQ2IsVUFBVSxFQUFFLFdBQVc7UUFDdkIsT0FBTyxFQUFFLFdBQVcsQ0FBQyxPQUFPO1FBQzVCLE1BQU0sRUFBRSxXQUFXLENBQUMsTUFBTTtRQUMxQixTQUFTLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLFNBQVM7UUFDakQsU0FBUyxFQUFF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QUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDNUQsT0FBTyx1QkFBdUIsQ0FBQyxHQUFHLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUN4RCxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELEtBQUssVUFBVSx1QkFBdUIsQ0FBQyxHQUFTLEVBQUUsZ0JBQWtDO0lBQ2xGLDhFQUE4RTtJQUM5RSxNQUFNLGVBQWUsR0FBRyx1QkFBdUIsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDMUUsR0FBRyxDQUFDLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBRTNDLElBQUk7UUFDRixLQUFLLE1BQU0sSUFBSSxJQUFJLGdCQUFnQixDQUFDLGFBQWEsRUFBRTtZQUNqRCxlQUFLLENBQUMsTUFBTSxhQUFJLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDMUM7UUFDRCxPQUFPLE1BQU0sZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzFDO1lBQVM7UUFDUixLQUFLLE1BQU0sSUFBSSxJQUFJLGdCQUFnQixDQUFDLGFBQWEsRUFBRTtZQUNqRCxlQUFLLENBQUMsR0FBRyxhQUFJLFFBQVEsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztTQUN0RTtRQUNELEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQztLQUM1QztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBwcmludCB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgSVNESywgTW9kZSwgU2RrUHJvdmlkZXIgfSBmcm9tICcuL2F3cy1hdXRoJztcbmltcG9ydCB7IERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi9kZXBsb3ktc3RhY2snO1xuaW1wb3J0IHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLCBMYXp5TGlzdFN0YWNrUmVzb3VyY2VzIH0gZnJvbSAnLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvYXBwc3luYy1tYXBwaW5nLXRlbXBsYXRlcyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUNvZGVCdWlsZFByb2plY3RDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvY29kZS1idWlsZC1wcm9qZWN0cyc7XG5pbXBvcnQgeyBJQ09OLCBDaGFuZ2VIb3Rzd2FwSW1wYWN0LCBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBIb3Rzd2FwT3BlcmF0aW9uLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgfSBmcm9tICcuL2hvdHN3YXAvY29tbW9uJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9lY3Mtc2VydmljZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9sYW1iZGEtZnVuY3Rpb25zJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL3MzLWJ1Y2tldC1kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9zdGVwZnVuY3Rpb25zLXN0YXRlLW1hY2hpbmVzJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBob3Rzd2FwIGRlcGxveW1lbnQsXG4gKiBzaG9ydC1jaXJjdWl0aW5nIENsb3VkRm9ybWF0aW9uIGlmIHBvc3NpYmxlLlxuICogSWYgaXQncyBub3QgcG9zc2libGUgdG8gc2hvcnQtY2lyY3VpdCB0aGUgZGVwbG95bWVudFxuICogKGJlY2F1c2UgdGhlIENESyBTdGFjayBjb250YWlucyBjaGFuZ2VzIHRoYXQgY2Fubm90IGJlIGRlcGxveWVkIHdpdGhvdXQgQ2xvdWRGb3JtYXRpb24pLFxuICogcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyeUhvdHN3YXBEZXBsb3ltZW50KFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIGFzc2V0UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICBjbG91ZEZvcm1hdGlvblN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrLCBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIHJlc29sdmUgdGhlIGVudmlyb25tZW50LCBzbyB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGluZ3MgbGlrZSBBV1M6OlJlZ2lvbiBpbiBDRk4gZXhwcmVzc2lvbnNcbiAgY29uc3QgcmVzb2x2ZWRFbnYgPSBhd2FpdCBzZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2tBcnRpZmFjdC5lbnZpcm9ubWVudCk7XG4gIC8vIGNyZWF0ZSBhIG5ldyBTREsgdXNpbmcgdGhlIENMSSBjcmVkZW50aWFscywgYmVjYXVzZSB0aGUgZGVmYXVsdCBvbmUgd2lsbCBub3Qgd29yayBmb3IgbmV3LXN0eWxlIHN5bnRoZXNpcyAtXG4gIC8vIGl0IGFzc3VtZXMgdGhlIGJvb3RzdHJhcCBkZXBsb3kgUm9sZSwgd2hpY2ggZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIHRvIHVwZGF0ZSBMYW1iZGEgZnVuY3Rpb25zXG4gIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChyZXNvbHZlZEVudiwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuICAvLyBUaGUgY3VycmVudCByZXNvdXJjZXMgb2YgdGhlIFN0YWNrLlxuICAvLyBXZSBuZWVkIHRoZW0gdG8gZmlndXJlIG91dCB0aGUgcGh5c2ljYWwgbmFtZSBvZiBhIHJlc291cmNlIGluIGNhc2UgaXQgd2Fzbid0IHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAgLy8gV2UgZmV0Y2ggaXQgbGF6aWx5LCB0byBzYXZlIGEgc2VydmljZSBjYWxsLCBpbiBjYXNlIGFsbCBob3Rzd2FwcGVkIHJlc291cmNlcyBoYXZlIHRoZWlyIHBoeXNpY2FsIG5hbWVzIHNldC5cbiAgY29uc3QgbGlzdFN0YWNrUmVzb3VyY2VzID0gbmV3IExhenlMaXN0U3RhY2tSZXNvdXJjZXMoc2RrLCBzdGFja0FydGlmYWN0LnN0YWNrTmFtZSk7XG4gIGNvbnN0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUgPSBuZXcgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKHtcbiAgICBzdGFja0FydGlmYWN0LFxuICAgIHBhcmFtZXRlcnM6IGFzc2V0UGFyYW1zLFxuICAgIGFjY291bnQ6IHJlc29sdmVkRW52LmFjY291bnQsXG4gICAgcmVnaW9uOiByZXNvbHZlZEVudi5yZWdpb24sXG4gICAgcGFydGl0aW9uOiAoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLnBhcnRpdGlvbixcbiAgICB1cmxTdWZmaXg6IChyZWdpb24pID0+IHNkay5nZXRFbmRwb2ludFN1ZmZpeChyZWdpb24pLFxuICAgIGxpc3RTdGFja1Jlc291cmNlcyxcbiAgfSk7XG5cbiAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgY2xvdWRGb3JtYXRpb25TdGFjay50ZW1wbGF0ZSgpO1xuICBjb25zdCBzdGFja0NoYW5nZXMgPSBjZm5fZGlmZi5kaWZmVGVtcGxhdGUoY3VycmVudFRlbXBsYXRlLCBzdGFja0FydGlmYWN0LnRlbXBsYXRlKTtcbiAgY29uc3QgaG90c3dhcHBhYmxlQ2hhbmdlcyA9IGF3YWl0IGZpbmRBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHN0YWNrQ2hhbmdlcywgZXZhbHVhdGVDZm5UZW1wbGF0ZSk7XG4gIGlmICghaG90c3dhcHBhYmxlQ2hhbmdlcykge1xuICAgIC8vIHRoaXMgbWVhbnMgdGhlcmUgd2VyZSBjaGFuZ2VzIHRvIHRoZSB0ZW1wbGF0ZSB0aGF0IGNhbm5vdCBiZSBzaG9ydC1jaXJjdWl0ZWRcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gYXBwbHkgdGhlIHNob3J0LWNpcmN1aXRhYmxlIGNoYW5nZXNcbiAgYXdhaXQgYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHNkaywgaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgcmV0dXJuIHsgbm9PcDogaG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDAsIHN0YWNrQXJuOiBjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrSWQsIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgc3RhY2tDaGFuZ2VzOiBjZm5fZGlmZi5UZW1wbGF0ZURpZmYsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8SG90c3dhcE9wZXJhdGlvbltdIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IHJlc291cmNlRGlmZmVyZW5jZXMgPSBnZXRTdGFja1Jlc291cmNlRGlmZmVyZW5jZXMoc3RhY2tDaGFuZ2VzKTtcblxuICBsZXQgZm91bmROb25Ib3Rzd2FwcGFibGVDaGFuZ2UgPSBmYWxzZTtcbiAgY29uc3QgcHJvbWlzZXM6IEFycmF5PEFycmF5PFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4+PiA9IFtdO1xuICAvLyBnYXRoZXIgdGhlIHJlc3VsdHMgb2YgdGhlIGRldGVjdG9yIGZ1bmN0aW9uc1xuICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIGNoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzb3VyY2VEaWZmZXJlbmNlcykpIHtcbiAgICBjb25zdCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uID0gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhjaGFuZ2UpO1xuXG4gICAgaWYgKHJlc291cmNlSG90c3dhcEV2YWx1YXRpb24gPT09IENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UKSB7XG4gICAgICBmb3VuZE5vbkhvdHN3YXBwYWJsZUNoYW5nZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChyZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uID09PSBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQpIHtcbiAgICAgIC8vIGVtcHR5ICdpZicganVzdCBmb3IgZmxvdy1hd2FyZSB0eXBpbmcgdG8ga2ljayBpbi4uLlxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlcy5wdXNoKFtcbiAgICAgICAgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShsb2dpY2FsSWQsIHJlc291cmNlSG90c3dhcEV2YWx1YXRpb24sIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpLFxuICAgICAgICBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZShsb2dpY2FsSWQsIHJlc291cmNlSG90c3dhcEV2YWx1YXRpb24sIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpLFxuICAgICAgICBpc0hvdHN3YXBwYWJsZUVjc1NlcnZpY2VDaGFuZ2UobG9naWNhbElkLCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uLCBldmFsdWF0ZUNmblRlbXBsYXRlKSxcbiAgICAgICAgaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UobG9naWNhbElkLCByZXNvdXJjZUhvdHN3YXBFdmFsdWF0aW9uLCBldmFsdWF0ZUNmblRlbXBsYXRlKSxcbiAgICAgICAgaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlKGxvZ2ljYWxJZCwgcmVzb3VyY2VIb3Rzd2FwRXZhbHVhdGlvbiwgZXZhbHVhdGVDZm5UZW1wbGF0ZSksXG4gICAgICAgIGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZShsb2dpY2FsSWQsIHJlc291cmNlSG90c3dhcEV2YWx1YXRpb24sIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpLFxuICAgICAgXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBhbGwgZGV0ZWN0b3IgcmVzdWx0c1xuICBjb25zdCBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0czogQXJyYXk8QXJyYXk8Q2hhbmdlSG90c3dhcFJlc3VsdD4+ID0gW107XG4gIGZvciAoY29uc3QgZGV0ZWN0b3JSZXN1bHRQcm9taXNlcyBvZiBwcm9taXNlcykge1xuICAgIGNvbnN0IGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoZGV0ZWN0b3JSZXN1bHRQcm9taXNlcyk7XG4gICAgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMucHVzaChob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyk7XG4gIH1cblxuICBjb25zdCBob3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8SG90c3dhcE9wZXJhdGlvbj4oKTtcbiAgZm9yIChjb25zdCBob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyBvZiBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgIGNvbnN0IHBlckNoYW5nZUhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxIb3Rzd2FwT3BlcmF0aW9uPigpO1xuXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgaG90c3dhcERldGVjdGlvblJlc3VsdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBwZXJDaGFuZ2VIb3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGZvdW5kIGFueSBob3Rzd2FwcGFibGUgY2hhbmdlcywgcmV0dXJuIG5vd1xuICAgIGlmIChwZXJDaGFuZ2VIb3Rzd2FwcGFibGVSZXNvdXJjZXMubGVuZ3RoID4gMCkge1xuICAgICAgaG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goLi4ucGVyQ2hhbmdlSG90c3dhcHBhYmxlUmVzb3VyY2VzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIG5vIGhvdHN3YXBwYWJsZSBjaGFuZ2VzIGZvdW5kLCBzbyBhdCBsZWFzdCBvbmUgSVJSRUxFVkFOVCBtZWFucyB3ZSBjYW4gaWdub3JlIHRoaXMgY2hhbmdlO1xuICAgIC8vIG90aGVyd2lzZSwgYWxsIGFuc3dlcnMgYXJlIFJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVCwgc28gdGhpcyBtZWFucyB3ZSBjYW4ndCBob3Rzd2FwIHRoaXMgY2hhbmdlLFxuICAgIC8vIGFuZCBoYXZlIHRvIGRvIGEgZnVsbCBkZXBsb3ltZW50IGluc3RlYWRcbiAgICBpZiAoIWhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzLnNvbWUoaGRyID0+IGhkciA9PT0gQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UKSkge1xuICAgICAgZm91bmROb25Ib3Rzd2FwcGFibGVDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3VuZE5vbkhvdHN3YXBwYWJsZUNoYW5nZSA/IHVuZGVmaW5lZCA6IGhvdHN3YXBwYWJsZVJlc291cmNlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBjaGFuZ2VzIHRvIHJlc291cmNlcyBpbiB0aGUgZ2l2ZW4gU3RhY2suXG4gKlxuICogQHBhcmFtIHN0YWNrQ2hhbmdlcyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgY2hhbmdlcyB0byBhIGdpdmVuIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZik6IHsgW2xvZ2ljYWxJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIH0ge1xuICAvLyB3ZSBuZWVkIHRvIGNvbGxhcHNlIGxvZ2ljYWwgSUQgcmVuYW1lIGNoYW5nZXMgaW50byBvbmUgY2hhbmdlLFxuICAvLyBhcyB0aGV5IGFyZSByZXByZXNlbnRlZCBpbiBzdGFja0NoYW5nZXMgYXMgYSBwYWlyIG9mIHR3byBjaGFuZ2VzOiBvbmUgYWRkaXRpb24gYW5kIG9uZSByZW1vdmFsXG4gIGNvbnN0IGFsbFJlc291cmNlQ2hhbmdlczogeyBbbG9nSWQ6IHN0cmluZ106IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB9ID0gc3RhY2tDaGFuZ2VzLnJlc291cmNlcy5jaGFuZ2VzO1xuICBjb25zdCBhbGxSZW1vdmFsQ2hhbmdlcyA9IGZpbHRlckRpY3QoYWxsUmVzb3VyY2VDaGFuZ2VzLCByZXNDaGFuZ2UgPT4gcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGNvbnN0IGFsbE5vblJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIHJlc0NoYW5nZSA9PiAhcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGZvciAoY29uc3QgW2xvZ0lkLCBub25SZW1vdmFsQ2hhbmdlXSBvZiBPYmplY3QuZW50cmllcyhhbGxOb25SZW1vdmFsQ2hhbmdlcykpIHtcbiAgICBpZiAobm9uUmVtb3ZhbENoYW5nZS5pc0FkZGl0aW9uKSB7XG4gICAgICBjb25zdCBhZGRDaGFuZ2UgPSBub25SZW1vdmFsQ2hhbmdlO1xuICAgICAgLy8gc2VhcmNoIGZvciBhbiBpZGVudGljYWwgcmVtb3ZhbCBjaGFuZ2VcbiAgICAgIGNvbnN0IGlkZW50aWNhbFJlbW92YWxDaGFuZ2UgPSBPYmplY3QuZW50cmllcyhhbGxSZW1vdmFsQ2hhbmdlcykuZmluZCgoW18sIHJlbUNoYW5nZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2UocmVtQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgICAvLyBpZiB3ZSBmb3VuZCBvbmUsIHRoZW4gdGhpcyBtZWFucyB0aGlzIGlzIGEgcmVuYW1lIGNoYW5nZVxuICAgICAgaWYgKGlkZW50aWNhbFJlbW92YWxDaGFuZ2UpIHtcbiAgICAgICAgY29uc3QgW3JlbW92ZWRMb2dJZCwgcmVtb3ZlZFJlc291cmNlQ2hhbmdlXSA9IGlkZW50aWNhbFJlbW92YWxDaGFuZ2U7XG4gICAgICAgIGFsbE5vblJlbW92YWxDaGFuZ2VzW2xvZ0lkXSA9IG1ha2VSZW5hbWVEaWZmZXJlbmNlKHJlbW92ZWRSZXNvdXJjZUNoYW5nZSwgYWRkQ2hhbmdlKTtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSByZW1vdmFsIGNoYW5nZSB0aGF0IGZvcm1zIHRoZSByZW5hbWUgcGFpclxuICAgICAgICBkZWxldGUgYWxsUmVtb3ZhbENoYW5nZXNbcmVtb3ZlZExvZ0lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBhcmUgYWxsIG9mIHRoZSByZW1haW5pbmcgcmVtb3ZhbCBjaGFuZ2VzLFxuICAvLyBwbHVzIGFsbCBvZiB0aGUgbm9uLXJlbW92YWwgY2hhbmdlc1xuICAvLyAod2Ugc2F2ZWQgdGhlIHJlbmFtZSBjaGFuZ2VzIGluIHRoYXQgb2JqZWN0IGFscmVhZHkpXG4gIHJldHVybiB7XG4gICAgLi4uYWxsUmVtb3ZhbENoYW5nZXMsXG4gICAgLi4uYWxsTm9uUmVtb3ZhbENoYW5nZXMsXG4gIH07XG59XG5cbi8qKiBGaWx0ZXJzIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxiYWNrIHJldHVybnMgJ3RydWUnIGZvciB0aGUgZ2l2ZW4gdmFsdWUgaW4gdGhlIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZpbHRlckRpY3Q8VD4oZGljdDogeyBba2V5OiBzdHJpbmddOiBUIH0sIGZ1bmM6ICh0OiBUKSA9PiBib29sZWFuKTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGljdCkucmVkdWNlKChhY2MsIFtrZXksIHRdKSA9PiB7XG4gICAgaWYgKGZ1bmModCkpIHtcbiAgICAgIGFjY1trZXldID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30gYXMgeyBba2V5OiBzdHJpbmddOiBUIH0pO1xufVxuXG4vKiogUmV0dXJucyAndHJ1ZScgaWYgYSBwYWlyIG9mIGNoYW5nZXMgaXMgZm9yIHRoZSBzYW1lIHJlc291cmNlLiAqL1xuZnVuY3Rpb24gY2hhbmdlc0FyZUZvclNhbWVSZXNvdXJjZShvbGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSwgbmV3Q2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIG9sZENoYW5nZS5vbGRSZXNvdXJjZVR5cGUgPT09IG5ld0NoYW5nZS5uZXdSZXNvdXJjZVR5cGUgJiZcbiAgICAgIC8vIHRoaXMgaXNuJ3QgZ3JlYXQsIGJ1dCBJIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gc29tZXRoaW5nIGxpa2UgdW5kZXJzY29yZSBqdXN0IGZvciB0aGlzIGNvbXBhcmlzb25cbiAgICAgIEpTT04uc3RyaW5naWZ5KG9sZENoYW5nZS5vbGRQcm9wZXJ0aWVzKSA9PT0gSlNPTi5zdHJpbmdpZnkobmV3Q2hhbmdlLm5ld1Byb3BlcnRpZXMpO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVuYW1lRGlmZmVyZW5jZShcbiAgcmVtQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIGFkZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuKTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIHtcbiAgcmV0dXJuIG5ldyBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UoXG4gICAgLy8gd2UgaGF2ZSB0byBmaWxsIGluIHRoZSBvbGQgdmFsdWUsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoaXMgd2lsbCBiZSBjbGFzc2lmaWVkIGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VcbiAgICByZW1DaGFuZ2Uub2xkVmFsdWUsXG4gICAgYWRkQ2hhbmdlLm5ld1ZhbHVlLFxuICAgIHtcbiAgICAgIHJlc291cmNlVHlwZToge1xuICAgICAgICBvbGRUeXBlOiByZW1DaGFuZ2Uub2xkUmVzb3VyY2VUeXBlLFxuICAgICAgICBuZXdUeXBlOiBhZGRDaGFuZ2UubmV3UmVzb3VyY2VUeXBlLFxuICAgICAgfSxcbiAgICAgIHByb3BlcnR5RGlmZnM6IChhZGRDaGFuZ2UgYXMgYW55KS5wcm9wZXJ0eURpZmZzLFxuICAgICAgb3RoZXJEaWZmczogKGFkZENoYW5nZSBhcyBhbnkpLm90aGVyRGlmZnMsXG4gICAgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaWYgYSByZXNvdXJjZSB3YXMgZGVsZXRlZCwgb3IgYSBjaGFuZ2UgdGhhdCB3ZSBjYW5ub3Qgc2hvcnQtY2lyY3VpdCBvY2N1cmVkLlxuICogUmV0dXJucyBgQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UYCBpZiBhIGNoYW5nZSB0aGF0IGRvZXMgbm90IGltcGFjdCBzaG9ydGNpcmN1aXRpbmcgb2NjdXJlZCwgc3VjaCBhcyBhIG1ldGFkYXRhIGNoYW5nZS5cbiAqL1xuZnVuY3Rpb24gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSk6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB8IENoYW5nZUhvdHN3YXBJbXBhY3Qge1xuICAvLyBhIHJlc291cmNlIGhhcyBiZWVuIHJlbW92ZWQgT1IgYSByZXNvdXJjZSBoYXMgYmVlbiBhZGRlZDsgd2UgY2FuJ3Qgc2hvcnQtY2lyY3VpdCB0aGF0IGNoYW5nZVxuICBpZiAoIWNoYW5nZS5uZXdWYWx1ZSB8fCAhY2hhbmdlLm9sZFZhbHVlKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgLy8gSWdub3JlIE1ldGFkYXRhIGNoYW5nZXNcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlID09PSAnQVdTOjpDREs6Ok1ldGFkYXRhJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5ld1ZhbHVlOiBjaGFuZ2UubmV3VmFsdWUsXG4gICAgcHJvcGVydHlVcGRhdGVzOiBjaGFuZ2UucHJvcGVydHlVcGRhdGVzLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhcHBseUFsbEhvdHN3YXBwYWJsZUNoYW5nZXMoc2RrOiBJU0RLLCBob3Rzd2FwcGFibGVDaGFuZ2VzOiBIb3Rzd2FwT3BlcmF0aW9uW10pOiBQcm9taXNlPHZvaWRbXT4ge1xuICBwcmludChgXFxuJHtJQ09OfSBob3Rzd2FwcGluZyByZXNvdXJjZXM6YCk7XG4gIHJldHVybiBQcm9taXNlLmFsbChob3Rzd2FwcGFibGVDaGFuZ2VzLm1hcChob3Rzd2FwT3BlcmF0aW9uID0+IHtcbiAgICByZXR1cm4gYXBwbHlIb3Rzd2FwcGFibGVDaGFuZ2Uoc2RrLCBob3Rzd2FwT3BlcmF0aW9uKTtcbiAgfSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhcHBseUhvdHN3YXBwYWJsZUNoYW5nZShzZGs6IElTREssIGhvdHN3YXBPcGVyYXRpb246IEhvdHN3YXBPcGVyYXRpb24pOiBQcm9taXNlPGFueT4ge1xuICAvLyBub3RlIHRoZSB0eXBlIG9mIHNlcnZpY2UgdGhhdCB3YXMgc3VjY2Vzc2Z1bGx5IGhvdHN3YXBwZWQgaW4gdGhlIFVzZXItQWdlbnRcbiAgY29uc3QgY3VzdG9tVXNlckFnZW50ID0gYGNkay1ob3Rzd2FwL3N1Y2Nlc3MtJHtob3Rzd2FwT3BlcmF0aW9uLnNlcnZpY2V9YDtcbiAgc2RrLmFwcGVuZEN1c3RvbVVzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuXG4gIHRyeSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGhvdHN3YXBPcGVyYXRpb24ucmVzb3VyY2VOYW1lcykge1xuICAgICAgcHJpbnQoYCAgICR7SUNPTn0gJXNgLCBjaGFsay5ib2xkKG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGhvdHN3YXBPcGVyYXRpb24uYXBwbHkoc2RrKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgaG90c3dhcE9wZXJhdGlvbi5yZXNvdXJjZU5hbWVzKSB7XG4gICAgICBwcmludChgJHtJQ09OfSAlcyAlc2AsIGNoYWxrLmJvbGQobmFtZSksIGNoYWxrLmdyZWVuKCdob3Rzd2FwcGVkIScpKTtcbiAgICB9XG4gICAgc2RrLnJlbW92ZUN1c3RvbVVzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuICB9XG59XG4iXX0=